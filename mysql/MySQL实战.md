# MySQL实战

## 基础架构：一条SQL查询语句是怎么执行的？

![1550835754343](E:\kaikeba\wjy\mysql\assets\1550835754343.png)

​	大体说，MySQL可以分为Sever层和存储引擎层两部分。

​	Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心功能，包括全部 内置函数。所有跨引擎层的功能都在这一层实现，比如存储过程、触发器、视图等。

​	存储引擎层主要负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等。

+ **连接器**

  + 负责跟客户端建立连接，获取权限，维持和管理连接。

  + 连接建立，获取用户权限。

  + show processlist查看连接状态。

  + 如果连接太长时间没动，会自动断开，这个时间由参数wait_timeout控制，默认8小时。

  + 连接分为长连接和短连接，建立连接的过程比较复杂，尽量使用长连接。

  + 使用长连接注意事项：

    + 全部使用长连接以后，可能MySQL内存涨得快，这是因为执行过程中临时使用的内存是管理在连接对象里面的，要断开连接才会释放，累计下来导致内存占用过大，被系统强行杀掉（OOM），从现象看就是异常重启。

    + 怎么解决：

      1、定期断开长连接。

      2、如果是5.7以上版本，可以在执行一个比较大的操作以后，执行mysql_reset_connection来重新初始化连接资源。恢复连接到刚刚建立时的状态。

+ **查询缓存**

  + 查询缓存往往会失效。

  + 查询缓存可以按需开启，设置query_cache_type=DEMAND，查询中指定SQL_CACHE指定查询缓存。

    ```sql
    mysql> select SQL_CACHE * from T where ID=10；
    ```

    

  + MySQL8.0以后没有查询缓存功能。

+ **分析器**

  + 词法分析
  + 语法分析

+ **优化器**

  + 优化器根据执行效率决定使用哪种查询方案。

    ```sql
    mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
    ```

    + 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
    + 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。

+ **执行器**

  + 首先判断用户有没有查询对应表的权限（如果命中缓存，在返回结果前验证权限。查询也会在优化器之前调用precheck验证权限）。
  + 权限验证通过，打开表，调用引擎提供的接口。
  + 循环调用引擎提供的接口，一条条判断是否满足条件，满足就存入结果集，不满足就跳过。
  + 慢查询日志中的rows_examined字段是执行器每次调用引擎获取数据时累加的。某些场景下，执行器调用一次，在引擎内部扫描多行，因此，**引擎扫描行数和rows_examined并不完全相同**。
  
  对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。
  
  你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

## 日志系统：一条SQL更新语句是怎么执行的？

​	更新语句会导致跟这个表有关的查询缓存失效。优化器决定使用哪一个索引，执行器负责找到这一行数据，然后更新。

+ **redo log**

  + 如果每次更新都写磁盘，整个IO过程成本很高。
  + MySQL中经常说到的技术WAL（Write-Ahead Logging），**先写日志，再写磁盘**。InnoDB先将记录写到redo log，更新内存，这时更新就算完成了。InnoDB会在适当的时候，将redo log的内容更新到磁盘。
  + redo log文件是固定大小的，可以配置为一组4个文件，文件是循环写的。![1550912910765](E:\kaikeba\wjy\mysql\assets\1550912910765.png)
  + write pos是当前记录的位置，checkpoint是当前要擦除的位置。擦除前会把记录更新到磁盘。write pos和checkpoint之间的就是可以擦除的位置。
  + write pos追上checkpoint时，说明redo log已经写满，这时更新操作需要停下来，擦掉记录，讲checkpoint往前推进。
  + 有了redo log可以保证异常重启以后，数据不丢失，这个能力叫**crash-safe**。

+ **binlog**

  ​	Binlog有两种模式，statement 格式的话是记sql语句， row格式会记录行的内容，记两条，更新前和更新后都有。

  + redo log和binlog主要有以下三点不同：
  
    + redo log是InnoDB特有的日志文件，binlog是server层的日志文件。
  + redo log是物理日志，记录“在某个数据页上做了什么修改”；binlog是逻辑日志，记录这个语句的原始逻辑，比如“给ID=2这一行数据的C字段加1”。
    + redo log的循环写的，空间会用完；binlog是追加写入，当前文件写到一定大小，切换到下一个文件，不会覆盖以前的文件。

  + 更新语句的执行流程：

    ![1550913563951](E:\kaikeba\wjy\mysql\assets\1550913563951.png)

  + **两阶段提交**

    redo log和binlog都可以用来表示事务提交状态，两阶段提交就是让这两个状态逻辑上保持一致。
  
    + 1、prepare阶段 2、写binlog 3、commit
    + 当在2之前崩溃，重启恢复，发现没有commit，回滚；备份恢复：没有binlog；一致。
    + 当在3之前崩溃，重启恢复，虽然没有commit，但redo log和binlog日志完整，重启后自动commit；备份有binlog，一致。

## 事务隔离：为什么你改了我还是看不见？

​	事务就是要保证一组数据库操作，要么全部成功，要么全部失败。事务支持是在存储引擎层实现的。

+ **隔离性和隔离级别**

  + MySQL默认隔离级别“可重复读”，Oracle默认隔离级别“提交读”。
  + show variables like 'transaction-isolation';查看事务隔离级别。

+ **事务隔离的实现（可重复读隔离级别）**

  + MySQL每一个更新操作的同时，会记录一个回滚操作。回滚段示意如下（执行顺序1->2->3->4）：

    ![1551011937733](E:\kaikeba\wjy\mysql\assets\1551011937733.png)

  + 不同时刻启动的事务，会有不同的read-view；同一条记录在系统中存在多个版本，就是数据库的多版本并发控制（MVCC）。

  + 回滚段在系统判定不需要的时候，会删除回滚段（当系统中没有比这个回滚段更新的read-view的时候）。

  + 如果存在长事务，意味着系统里存在很多老的事务视图，在这个事务提前之前，它用到的回滚段记录都必须保留，会占用大量存储空间

  + 在MySQL5.5之前，回滚日志跟数据字典一起存放在ibdata文件里面，即使事务提交，回滚段被清理，文件也不会变小。

  + 长事务还会占用锁资源，可能拖垮整个库。

+ **事务的启动方式**

  + 事务的开启方式有两种：

    + 显示启动事务，begin或start transaction，提交语句是commit，回滚语句是rollback。
    + set autocommit=0，关闭自动提交；意味着你只执行一个select，事务就开始了，直到执行commit或rollback，或者断开连接。

  + 在autocommit=1的情况下，执行begin显示开始一个事务，执行commit提交事务。如果执行commit work and chain，则提交事务并启动下一个事务。

  + 可以在infomation_schema库的innodb_trx表中查询长事务：

    ```sql
    select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
    ```

+ **如何避免长事务**

  + 应用开发端
    + 确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
    + 确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
    + 业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。
  + 数据库端
    + 监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill。
    + Percona 的 pt-kill 这个工具不错，推荐使用。
    + 在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题。
    + 如果使用的是 MySQL  5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。

## 深入浅出索引

+ **索引常见模型**

  + Hash表模型，适合于等值查询场景（区间查询需要扫描所有key），比如Memcached等NoSQL数据库
  + 有序数组，在等值查询和范围查询场景中的性能都很优秀，插入时需要移动数据，成本较高；适用于静态数据存储。
  + 二叉树，查询时间复杂度O(log(N))，为了维持这个时间复杂度，需要保持这个棵树的平衡。
    + 二叉树的搜索效率最高，但是大多数数据库存储不用二叉树，因为索引不止存在内存中，还存在磁盘上。
    + 数据量很大时，二叉树的树高比较大，访问层级越深，访问的数据块越多，访问越慢。
    + 为了减少访问数据块，采用“N叉树”，N取决于数据块的大小。
    + InnoDB整数字段索引，N的值差不多是1200。树高为4的时候，就可以存放1200的3次方条数据（17亿）。树根总是在内存中，查找一条数据，最多访问3次磁盘，其实第二层也很可能在内存中，这样访问磁盘的次数就更少。
  + 不同的存储引擎，索引的实现和工作方式不同。

+ **InnoDB索引模型**

  ![1551024816855](E:\kaikeba\wjy\mysql\assets\1551024816855.png)

  + 表的数据是根据主键顺序以索引的方式存放的，这种存储方式的表被称为**索引组织表**。
  + InnoDB使用B+树索引模型，所以数据都是存放到B+树中。
  + 每个索引对应一棵B+树。
  + 索引分为**主键索引**（聚簇索引cluster index，叶子节点存放的是整行数据）和**非主键索引**（**二级索引**，叶子节点存放主键的值）。
  + 基于普通索引查询，需要先搜索普通索引树，得到ID值，再到主键索引树搜索一次，这个过程叫**回表**。需要多查一棵树，所以应该尽量使用主键查询。

+ **索引维护**

  + 数据的插入，如果在中间插入，需要挪动后面的数据；如果当前数据页写满，要进行页分裂，会影响空间利用率。
  + 删除数据，当相邻的两个数据页空间利用率很低的时候，就要进行页合并。
  + 主键长度越小，普通索引的叶子节点就越小，普通索引占用空间也越小。

+ **索引重建**

  + 索引可能因为删除或者页分裂等原因，导致数据页有空洞。重建索引的目的是把数据按顺序插入，这样数据页的利用率更高，索引更紧凑，更节省空间。
  + 重建主键索引会导致整个表重建，可以执行：alter table T engine=InnoDB。

+ **覆盖索引**

  + 二级索引查询，如果要查询的字段已经存在二级索引上，就不需要回表了，二级索引覆盖了查询需求，称为覆盖索引。
  + 覆盖索引能有效的减少索引树的搜索次数，显著提升查询性能，是常用优化手段。
  + 对于高频查询请求，可以建立联合索引，使用覆盖索引，不用回表请求整行数据。

+ **最左前缀原则**

  + B+树的索引结构，可以利用“最左前缀”来定位记录。
  + 最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。
  + 如果可以通过调整顺序来少维护一个索引，那么这个顺序往往就是优先考虑采用的。
  + 联合索引（a,b），条件里只有b无法用到这个索引。

+ **索引下推**

  + MySQL5.6引入索引下推优化（index condition pushdown），可以在索引遍历的过程中，对索引中包含的字段优先判断，过滤掉不符合条件的记录，减少回表次数。

# 用到的命令

**查看连接状态：**show processlist

**重建表：**alter table T engine=InnoDB

**查看数据库状态**：show engine innodb status\G（查看死锁等信息）

# 用到的参数

**连接超时时间：**wait_timeout 默认8小时

**查询缓存开启类型：**query_cache_type=DEMAND（按需开启缓存）

**每次事务的redo log都直接持久化到磁盘**：innodb_flush_log_at_trx_commit=1（保证异常重启后数据不丢失）

**每次事务的binlog都持久化到磁盘：**sync_binlog=1（保证异常重启后binlog不丢失）

**事务提交级别：**transaction-isolation（READ-COMMITTED、REPEATABLE-READ）