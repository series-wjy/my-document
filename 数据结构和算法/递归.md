# 递归

递归需要满足三个条件：

1. **一个问题可以分解成若干个子问题的解。**

   子问题就是数据规模更小的问题。

2. **这个问题与分解后的子问题，除了数据规模不同，求解方式完全一样。**

3. **存在递归终止条件。**

   将问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，需要终止条件。

## 如何编写递归代码

写递归代码的关键是**写出递推公式，找到终止条件。**

**写递归代码的关键是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**

**编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**

## 递归代码警惕堆栈溢出

控制递归深度。

## 递归代码警惕重复计算

递归代码除了上述两种问题，还有些其他的问题。在效率上，当函数调用的数量比较大的时候，会累积客观的时间成本。在空间复杂度上，因为每次调用都会在内存栈中保持现场数据，所以在分析递归代码的空间复杂度时，需要额外考虑这部分开销。

## 将递归代码改为非递归代码

递归代码有利有弊，利是递归代码的表达力很强，写起来非常简洁；弊是空间复杂度高，有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。所以在开发过程中，要根据实际情况选择是否用递归来实现。

笼统的讲，任何递归都可以改成**迭代循环**的方式实现。

本质上来讲，递归本身就是借助栈来实现的，只不过是我们使用的栈是系统或者虚拟机提供的，我们没有感知罢了。我们可以手动模拟入栈、出栈过程，这样任何递归代码都可以改成不是递归的样子。

