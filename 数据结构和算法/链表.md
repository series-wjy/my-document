# 链表

缓存的大小有限制，当缓存满的时候，就要清理过期数据，常见的缓存淘汰策略有三种：先进先出FIFO（First In First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。

数组的内存空间分配需要连续的内存空间，如果申请一个100M大小的数组，当内存中没有足够大的、连续的内存空间，即使剩余的内存总可用空间大于100M，也会申请失败。而链表恰恰相反，它利用的是零散的内存空间，将这些零散的内存空间串联起来，所以链表不需要连续的内存空间。

![1557206282147](D:\data\数据结构和算法\assets\1557206282147.png)

链表有很多种结构，最常见的是三种：单链表、双向链表和循环链表。

## 单链表

![1557206396794](D:\data\数据结构和算法\assets\1557206396794.png)

链表通过指针将一组零散的内存块串联起来。内存块称为链表的“**结点**”。为了将所有的结点串联起来，每个链表结点除了存储数据之外，还需要记录下一个结点的地址。我们把这个记录下一个结点地址的指针叫做“**后继指针 next**”。

链表的第一个结点叫**头结点**记录链表的基地址，有了头结点就可以遍历整个链表。最后一个结点叫**尾结点**，尾结点的后继指针指向**空地址 NULL**，表示这是链表的最后一个结点。

链表的插入、删除操作的性能很高，因为不需要为了维持连续性而产生数据搬移操作，只需要改变相邻结点的指针改变，所以对应的时间复杂度是O(1)。

![1557206868935](D:\data\数据结构和算法\assets\1557206868935.png)

## 循环链表

**循环链表是一种特殊的单链表**。它和单链表唯一的区别就是尾结点。循环链表的尾结点指向链表的头结点。它像一个环一样首尾相连。

![1557211530804](D:\data\数据结构和算法\assets\1557211530804.png)

和单链表相比，循环链表的优点是从链尾到链头比较方便。处理环形结构的数据时，环形链表就特别适合，比如著名的**约瑟夫问题**

## 双向链表

双向链表支持两个方向，每个结点不止包含指向下一结点的指针**next**，还有一个前驱指针**prev**。

![1557211778550](D:\data\数据结构和算法\assets\1557211778550.png)

双向链表在删除、插入操作方面相比单链表更加高效。

在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：

+ 删除结点中“值等于某个给定值”的结点；
+ 删除给定指针指向的结点。

对于第一种情况，不管是单链表还是双向链表，都需要遍历链表查找需要删除的结点，删除结点并操作指针指向下一结点，查找是主要耗时，时间复杂度O(n)，删除的时间复杂度O(1)根据加法规则，删除结点的时间复杂度O(n)。

对于第二种情况，经找到了要删除的结点p，但是并不知道p的前驱结点，所以单链表需要遍历查找p的前驱结点。但是对于双向链表来，p结点已经包含了前驱结点，所以不需要遍历链表查找前驱结点，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。

同理，如果要插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。

除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

这就是为什么在实际的软件开发中，**双向链表尽管比较费内存**，但还是比单链表的应用更加广泛的原因。 LinkedHashMap 的底层实现原理就用到了双向链表这种数据结构。实际上，这是**空间换时间**的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用**时间换空间**的设计思路。

还有一种特殊的双向链表叫双向循环链表：

![1557212234893](D:\data\数据结构和算法\assets\1557212234893.png)

## 链表和数组性能比较

数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。

![1557212358212](D:\data\数据结构和算法\assets\1557212358212.png)

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

 Java 中的 ArrayList 容器也可以支持动态扩容，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。

## 写链表代码的技巧

### 1、理解指针或引用的含义

将某个变量赋值给指针，实际上就是将这个变量的内存地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

### 2、警惕指针丢失和内存泄漏

### 3、利用哨兵简化编程难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理，这种情况就可以利用哨兵机制，简化编程。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null) {
            return head;
        }
        ListNode sentinel = new ListNode(0);
        sentinel.next = head;
        ListNode fast = sentinel;
        ListNode slow = sentinel;
        for(int i = 0; i <= n; i ++) {
            if(fast == null) {
                return head;
            }
            fast = fast.next;
        }
        
        while(fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        
        slow.next = slow.next.next;
        head = sentinel.next;
        return head;
    }
}
```

### 4、重点留意边界条件处理

用来检查链表代码是否正确的边界条件有这样几个：

+ 如果链表为空时，代码是否能正常工作？
+ 如果链表只包含一个结点时，代码是否能正常工作？
+ 如果链表只包含两个结点时，代码是否能正常工作？
+ 代码逻辑在处理头结点和尾结点时，是否能正常工作？

### 5、举例画图，帮助思考

![1557800983479](D:\data\数据结构和算法\assets\1557800983479.png)

### 6、多练习多思考