

# 排序

## 如何分析一个排序算法

### 排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度

   + 有些算法会区分三种情况，为了对比，最好都做一下区分
   + 对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序执行时间肯定有影响，我们要知道排序算法在不同的数据下的性能表现。

2. 时间复杂度的系数、常数、低阶

   时间复杂度反应的是数据规模N很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数和低阶。但实际开发中，排序的数据规模比较小，所以，在对同一阶时间复杂的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进去。

3. 比较次数和交换（或移动）次数

   基于比较的排序算法的执行过程中，会涉及元素的**比较大小**和元素的**交换或移动**。所以在分析算法的执行效率时，也要把比较次数和移动（或交换）次数考虑进去。

### 排序算法的内存消耗

**原地排序算法（Sorted In Place）**：原地排序算法指的是空间复杂度为O(1)的排序算法。

### 排序算法的稳定性

**稳定性：**如果等待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，**对于每个金额相同的小区间再按照下单时间排序**。这种排序思路理解起来不难，但是实现起来会很复杂。

借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？

**稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。**第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。

![1558337902282](D:\data\数据结构和算法\assets\1558337902282.png)

## 冒泡排序

冒泡排序只会操作响铃的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系。如果不满足，让他们互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复N次，直到完成排序工作。

比如对一组数据：4，5，6，3，2，1从小到大进行排序。

![1558340897637](D:\data\数据结构和算法\assets\1558340897637.png)

经过一次冒泡排序操作后，6这个元素已经存储在正确的位置上。要想完成所有数据排序，我们要进行6次这样的排序操作就行了。

![1558340972019](D:\data\数据结构和算法\assets\1558340972019.png)

事实上，上面的冒泡排序算法还可以优化。当某次冒泡排序操作没有数据交换的时候，说明已经达到完全有序，不用再继续进行后续的冒泡操作了。比如下图的6个元素，只需要4次冒泡排序操作就可以了。

![1558341273607](D:\data\数据结构和算法\assets\1558341273607.png)

代码实现：

```java
	public static void bubbleSort() {
		int[] arr = {3,5,4,1,2,6};
		int length = arr.length;
		boolean exchange = false;
		for(int i = 0; i < length; i++) {
			for(int j = 0; j < length - i - 1; j++) {
				if(arr[j] > arr[j + 1]) {
					int tmp = arr[j + 1];
					arr[j + 1] = arr[j];
					arr[j] = tmp;
					exchange = true;
				}
			}
			if(!exchange) {
				break;
			}
		}
		System.out.println(Arrays.toString(arr));
	}
```

冒泡排序算法总结：

+ 冒泡排序算法过程只涉及相邻的数据交换，只需要常量级的临时空间，所以它的空间复杂度是O(1)，是一个原地排序算法。

+ 冒泡排序算法，相邻的两个元素相等时，不做交换操作，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

+ 最好的情况是要排序的数据已经有序，只需要进行一次排序就结束了，所以最好的情况时间复杂度是O(n)，最坏的情况是要排序的数据刚好是倒序排列的，我们需要进行N次冒泡排序，所以最坏情况时间复杂度是O(n^2)。

  ![1558343035949](D:\data\数据结构和算法\assets\1558343035949.png)

最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。

对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“**有序度**“和”**逆序度**“这两个概念来进行分析。

**有序度**是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：

```
有序元素对：a[i] <= a[j], 如果 i < j。
```

![1558343755693](D:\data\数据结构和算法\assets\1558343755693.png)

同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是**n*(n-1)/2**，也就是15。我们把这种完全有序的数组的有序度叫作**满有序度。**

逆序度的定义正好跟有序度相反（默认从小到大为有序），我想你应该已经想到了。关于逆序度，我就不举例子讲了。你可以对照我讲的有序度的例子自己看下。

```
逆序元素对：a[i] > a[j], 如果 i < j。
```

关于这三个概念，我们还可以得到一个公式：**逆序度 = 满有序度 - 有序度**。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。

![1558343989908](D:\data\数据结构和算法\assets\1558343989908.png)

冒泡排序包含两个操作原子，**比较**和**交换**。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为**逆序度**，也就是**n*(n-1)/2–初始有序度**。此例中就是 15–3=12，要进行 12 次交换操作。

对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n\*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n\*(n-1)/2，就不需要进行交换。我们可以取个中间值 n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n)，所以平均情况下的时间复杂度就是 O(n^2)。

这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。等我们讲到快排的时候，我还会再次用这种“不严格”的方法来分析平均时间复杂度。

## 插入排序

![1558344953314](D:\data\数据结构和算法\assets\1558344953314.png)

插入排序将排序数据分为**已排序区间**和**未排序区间**。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间的第一个元素，依次与排序区间的元素进行比较，找到合适的位置，插入要排序的元素，并保证已排序区间的元素是有序的。重复这个过程，直到未排序区间元素为空，排序结束。

如图所示，要排序的数据是4,5,6,1,3,2，其中左侧为已排序区间，右侧为未排序区间。

![1558418616842](D:\data\数据结构和算法\assets\1558418616842.png)

插入排序包含两种操作，一种是**元素比较**，一种是**元素移动**。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。

对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。

为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。

![1558418764168](D:\data\数据结构和算法\assets\1558418764168.png)

代码实现：

```java
	public void insertionSort() {
		int[] arr = {3,5,4,1,2,6};
		int length = arr.length;
		for(int i = 1; i < length; i++) {
			int tmp = arr[i];
			int j = i - 1;
			
			for(; j >= 0; --j) {
				if(arr[j] > tmp) {
					arr[j + 1] = arr[j];
				} else {
					break;
				}
			}
			arr[j + 1] = tmp;
		}
	}
```



插入排序算法总结：

- 从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个**原地排序**算法。

- 在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是**稳定的排序**算法。

- 如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是**从尾到头遍历已经有序的数据**。

  如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n^2)。

  在数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。

## 选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

![1558419509712](D:\data\数据结构和算法\assets\1558419509712.png)

代码实现:

```java

```

选择排序总结：

+ 选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)。

+ 选择排序不是稳定的排序算法，从图上可以看出，每次找到未排序元素中的最小元素，并和未排序区间的第一个元素进行位置交换，这样就破坏了稳定性。

  比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

## 冒泡排序和插入排序性能比较

前面分析冒泡排序和插入排序的时候，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：

```java
//冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

//插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。

所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下**[希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)**。

## 冒泡、插入、选择排序内容小结

![1558420295603](D:\data\数据结构和算法\assets\1558420295603.png)

这三种时间复杂度为 O(n^2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。后面讲排序优化的时候，我会讲到，有些编程语言中的排序函数的实现原理会用到插入排序算法。

## 归并排序

归并排序的核心思想是先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

![1558515131530](D:\data\数据结构和算法\assets\1558515131530.png)

归并排序使用的是**分治思想**。分治思想跟我们前面讲的递归思想很像，分治算法一般都是用递归来实现的。**分治是一种解决问题的处理思想，递归是一种编程技巧**。

```递推公式：
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

代码实现：

```java
	public void mergeSort(int[] arr, int s, int e) {
		// 递归终止条件
		if(s >= e) {
			return;
		}
		int mid = s + (e - s) / 2;
		mergeSort(arr, s, mid);
		mergeSort(arr, mid + 1, e);
		// 递归到不能划分的最小下标，根据下标将分组数据合并
		merge(arr, s, mid, e);
	}
	
	// 合并分组数据
	public void merge(int[] arr, int s, int mid, int e) {
		int i = s;
		int j = mid + 1;
		int k = 0;
		int[] tmp = new int[e - s + 1];
		// 合并两段数组{1,2}，{1,3,4}
		while(i <= mid && j <= e) {
			if(arr[i] < arr[j]) {
				tmp[k++] = arr[i++];
			} else {
				tmp[k++] = arr[j++];
			}
		}
		
		// 处理剩下的数组元素{3,4}
		int start = i, end = mid;
		if(j <= e) {
			start = j;
			end = e;
		}
		while(start <= end) {
			tmp[k++] = arr[start++];
		}
		// 将排好序的数组元素替换到原数组对应位置
		for(i = 0; i < k; i ++) {
			arr[s + i] = tmp[i];
		}
	}
```

如图所示，申请一个临时数组 tmp，大小与 A[p…r] 相同。用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]<=A[j]，就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。

![1558515377457](D:\data\数据结构和算法\assets\1558515377457.png)

归并排序算法总结：

+ 归并排序可以保证相等元素的前后顺序不变，所以是**稳定的排序算法**。

+ 不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。

  ```
  T(a) = T(b) + T(c) + K
  ```

  假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：

  ```
  T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
  T(n) = 2*T(n/2) + n； n>1
  ```

  再进一步分解一下计算过程求解T(n)：

  ```
  T(n) = 2*T(n/2) + n
       = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
       = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
       = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
       ......
       = 2^k * T(n/2^k) + k * n
       ......
  ```

  T(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。**所以归并排序的时间复杂度是 O(nlogn)**。

  从原理分析和代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，**不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)**。

+ **归并排序不是原地排序算法**，这是归并排序在实际工作中没有**快速排序**应用广泛的主要原因。

  这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。应该记住最重要的一点，那就是，**尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了**。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。

## 快速排序

快排的思想是：如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

![1558516505287](D:\data\数据结构和算法\assets\1558516505287.png)

```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

终止条件：
p >= r
```

代码实现：

```java
	public void quickSort(int[] arr, int s, int e) {
		// 递归终止条件
		if(s >= e) {
			return;
		}
		int mid = partition(arr, s, e);
		quickSort(arr, s, mid - 1);
		quickSort(arr, mid + 1, e);
	}
	
	// 分区方法，选定一个元素，将数组分为两段，并返回元素在数组中的位置
	private int partition(int[] arr, int s, int e) {
		// 大于pivot元素的第一个元素指针
		int i = s;
		// 遍历指针
		int j = s;
		int pivot = arr[e];
		for(; j < e; j++) {
			// 遍历元素并比较，小于pivot就和i位置的元素交换，并让i往后移动一个位置
			if(arr[j] < pivot) {
				int tmp = arr[i];
				arr[i++] = arr[j];
				arr[j] = tmp;
			}
		}
		int tmp = arr[i];
		arr[i] = pivot;
		arr[e] = tmp;
		return i;
	}
```

这里的处理有点类似选择排序。通过游标 i 把 A[p…r-1] 分成两部分。A[p…i-1] 的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1] 是“未处理区间”。我们每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i] 的位置。

在数组某个位置插入元素，需要搬移数据，非常耗时。这里使用一种处理技巧，就是交换，在 O(1) 的时间复杂度内完成插入操作。这里也借助这个思想，只需要将 A[i] 与 A[j] 交换，就可以在 O(1) 时间复杂度内将 A[j] 放到下标为 i 的位置。

![1558516929960](D:\data\数据结构和算法\assets\1558516929960.png)

归并排序和快速排序的区别：

![1558516983794](D:\data\数据结构和算法\assets\1558516983794.png)

可以发现，归并排序的处理过程是**由下到上**的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是**由上到下**的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是**非原地排序算法**。归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。

快速排序算法总结：

+ 快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，**快排的时间复杂度也是 O(nlogn)**。

  ```
  T(1) = C；   n=1 时，只需要常量级的执行时间，所以表示为 C。
  T(n) = 2*T(n/2) + n； n>1
  ```

  但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。

  举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。

+ 快速排序算法不是稳定的排序算法，因为涉及到元素的比较交换。
+ 快速排序算是原地排序算法。

## 线性排序

桶排序、计数排序、基数排序：**线性排序**，时间复杂度O(n)。不涉及元素的比较交换。对要排序的数据要求比较苛刻，**重点是掌握这些排序算法的使用场景。**

### 桶排序

+ 适用场景：**外部排序**，就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

+ 排序思想：将数据分到几个有序的桶里面，每个桶里面单独排序（**快速排序**），然后将排序的数据依次取出就是有序的数据。

  ![1558688890585](D:\data\数据结构和算法\assets\1558688890585.png)

桶排序对数据的要求：

+ 数据要可以分到M个桶里面，并且桶与桶之间要有大小顺序。
+ 各个桶的数据要分布均匀，极端情况下数据都划分到一个桶里面，这时时间复杂度就退化为O(nlogn)。

业务场景：

比如有个10G的文件，可以划分为100个小文件，将100个小文件分别加载到内存进行排序，最后按大小顺序合并到一个文件，就是最终要排序的文件数据了。如果划分为100个文件里面的数据不均匀，就将数据量大的文件再划分，直到能进行排序为止。

### 计数排序

