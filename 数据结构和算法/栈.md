# 栈

**后进者先出，先进者后出，就是典型的“栈”结构。**

![1557803144274](D:\data\数据结构和算法\assets\1557803144274.png)

从栈的操作特性来看，**栈是一种“操作受限”的线性表**，只允许在一端插入和删除数据。

**当某某个数据集只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，就应该首选“栈**这种数据结构。

## 实现栈结构

用数组实现的栈叫做**线性栈**，用链表实现的栈叫做**链式栈**。

```java
// 基于数组实现的顺序栈
public class ArrayStack {
  private String[] items;  // 数组
  private int count;       // 栈中元素个数
  private int n;           // 栈的大小

  // 初始化数组，申请一个大小为 n 的数组空间
  public ArrayStack(int n) {
    this.items = new String[n];
    this.n = n;
    this.count = 0;
  }
    
  // 入栈操作
  public boolean push(String item) {
    // 数组空间不够了，直接返回 false，入栈失败。
    if (count == n) return false;
    // 将 item 放到下标为 count 的位置，并且 count 加一
    items[count] = item;
    ++count;
    return true;
  }
  
  // 出栈操作
  public String pop() {
    // 栈为空，则直接返回 null
    if (count == 0) return null;
    // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一
    String tmp = items[count-1];
    --count;
    return tmp;
  }
}
```

## 支持动态扩容的顺序栈

![1557803403317](D:\data\数据结构和算法\assets\1557803403317.png)

为了分析的方便，需要事先做一些假设和定义：

+ 栈空间不够时，我们重新申请一个是原来大小两倍的数组；
+ 为了简化分析，假设只有入栈操作没有出栈操作；
+ 定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。

![1557803513788](D:\data\数据结构和算法\assets\1557803513788.png)

应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。

通过这个例子的实战分析，也印证了前面讲到的，**均摊时间复杂度一般都等于最好情况时间复杂度**。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。

## 栈在函数调用中的应用

```java
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}

```

从代码中可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况。

![1557803635212](D:\data\数据结构和算法\assets\1557803635212.png)

## 栈在表达式求值中的应用

![1557803664178](D:\data\数据结构和算法\assets\1557803664178.png)

## 栈在括号匹配中的应用

假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为不合法的格式。如何检查它是否合法呢？

用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

## 浏览器浏览网页后退前进

使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。

比如顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：

![1557803850367](D:\data\数据结构和算法\assets\1557803850367.png)

当通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：

![1557803878122](D:\data\数据结构和算法\assets\1557803878122.png)

这个时候又想看页面 b，于是又点击前进按钮回到 b 页面，就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：

![1557803909091](D:\data\数据结构和算法\assets\1557803909091.png)

这个时候，通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：

![1557803934592](D:\data\数据结构和算法\assets\1557803934592.png)